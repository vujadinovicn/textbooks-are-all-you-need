{"problem": "fun calculateAveragePrice(prices: MutableList<Double>): Double {\n    /**\n     * Calculate the average price of a list of fashion items.\n     *\n     * @param prices A list of prices of fashion items.\n     * @return The average price of the fashion items.\n     */", "solution": "\n    var total = 0.0\n\n    while (prices.isNotEmpty()) {\n        // Slices the prices list to get the first item and remove it from the original list\n        val price = prices.removeAt(0)\n\n        // Update the total variable by adding the current price\n        total += price\n    }\n\n    // Calculate the average price by dividing the total by the number of fashion items\n    val averagePrice = if (prices.isEmpty()) 0.0 else total / prices.size\n\n    return averagePrice\n}"}
{"problem": "fun findGene(sequence: String, targetGene: String): Int {\n    /**\n     * Given a DNA sequence and a target gene, this function returns the starting index of the target gene\n     * in the given sequence, using a while loop and boolean expressions.\n     *\n     * @param sequence A string representing the DNA sequence to search in\n     * @param targetGene A string representing the target gene to find\n     * @return The starting index of the target gene in the sequence, or -1 if not found.\n     */", "solution": "\n    var index = 0\n    val geneLen = targetGene.length\n\n    while (index <= sequence.length - geneLen) {\n        // Check if current substring matches the target gene\n        if (sequence.substring(index, index + geneLen) == targetGene) {\n            return index\n        }\n        index += 1\n    }\n\n    return -1  // Target gene not found in the given sequence\n}"}
{"problem": "fun getCommonWords(string1: String, string2: String): Set<String> {\n    /**\n     * This function takes in two strings and returns a set of common words found in both strings.\n     *\n     * @param string1 The first string.\n     * @param string2 The second string.\n     * @return A set of common words found in both strings.\n     *\n     * @throws IllegalArgumentException If either string1 or string2 is empty.\n     */", "solution": "\n    if (string1.isEmpty() || string2.isEmpty()) {\n        throw IllegalArgumentException(\"Both strings must not be empty\")\n    }\n\n    val words1 = string1.split(\" \")\n    val words2 = string2.split(\" \")\n    val commonWords = mutableSetOf<String>()\n\n    for (word1 in words1) {\n        for (word2 in words2) {\n            if (word1 == word2) {\n                commonWords.add(word1)\n            }\n        }\n    }\n\n    return commonWords\n}"}
{"problem": "fun advantagesEqual(musician1: Map<String, Any>, musician2: Map<String, Any>): Pair<Set<String>, Boolean> {\n    /**\n     * This exercise determines the intersection of advantages between two musicians and checks if they are equal.\n     */", "solution": "\n    // Find the advantages of musician1\n    val musician1Advantages = musician1[\"advantages\"] as? Set<String> ?: emptySet()\n\n    // Find the advantages of musician2\n    val musician2Advantages = musician2[\"advantages\"] as? Set<String> ?: emptySet()\n\n    // Find the common advantages between musician1 and musician2\n    val commonAdvantages = musician1Advantages.intersect(musician2Advantages)\n\n    // Check if the advantages are equal in count\n    val advantagesEqual = musician1Advantages.size == musician2Advantages.size\n\n    return Pair(commonAdvantages, advantagesEqual)\n}"}
{"problem": "fun createTuple(n: Int): Any {\n    /**\n     * Given an integer n, create a nested tuple using ternary operators.\n     *\n     * @param n The length of the nested tuple.\n     * @return Nested tuple of length n, where each element is either a tuple or a string 'Done'.\n     */", "solution": "\n    return if (n > 0) {\n        arrayOf(Pair(\"Done\", \"Done\").repeat(n))\n    } else {\n        \"Done\"\n    }\n}"}
{"problem": "fun createTuple(graphicDesignerName: String, graphicDesignerAge: Int, graphicDesignerSkillLevel: String, graphicDesignerExperience: Int): Pair<String, Any> {\n    \"\"\"\n    This exercise focuses on creating a tuple to store information about a graphic designer.\n    The tuple should include the designer's name, age, skill level, and experience.\n\n    Your task is to complete the code by creating a tuple with the provided information. Please make sure to follow the given order.\n\n    Args:\n    - graphicDesignerName (String): The name of the graphic designer.\n    - graphicDesignerAge (Int): The age of the graphic designer.\n    - graphicDesignerSkillLevel (String): The skill level of the graphic designer (e.g., Beginner, Intermediate, Advanced).\n    - graphicDesignerExperience (Int): The years of experience of the graphic designer.\n\n    Returns:\n    - Pair: A pair containing the provided information about the graphic designer.\n    \"\"\"", "solution": "\n    // Create a pair with the given information **in the correct order**\n    val graphicDesignerTuple = Pair(graphicDesignerName, listOf(graphicDesignerAge, graphicDesignerSkillLevel, graphicDesignerExperience))\n    \n    return graphicDesignerTuple\n\n// Example usage\nval designerInfo = createTuple(\"John\", 30, \"Intermediate\", 5)"}
{"problem": "fun intersectionSets(s1: Set<Int>, s2: Set<Int>): List<Int> {\n    \"\"\"\n    This exercise requires you to complete the code to find the intersection of two sets using list comprehension and iterating through sets.\n    \n    You are given two sets, s1 and s2, and you need to find the common elements between them. You should use list comprehension\n    to create a new list containing the common elements found in both sets. Finally, return the list with the common elements.\n    \n    Remember to use list comprehension and iterate through sets to solve this exercise. Good luck!\n    \"\"\"", "solution": "\n    val intersection = s1.filter { it in s2 } // Use filter to iterate through s1 and check if each element exists in s2\n\n    return intersection"}
{"problem": "fun findCommonElements(set1: Set<Int>, set2: Set<Int>): Set<Int> {\n    \"\"\"\n    This function takes two sets as input and returns a new set with only the elements that are \n    greater than or equal to the smallest element in the first set.\n    \n    Args:\n    set1 (Set): First input set\n    set2 (Set): Second input set\n    \n    Returns:\n    Set: A new set containing the common elements from both sets\n    \"\"\"", "solution": "\n    val minElement = set1.minOrNull() ?: return emptySet() // Find the smallest element in set1\n    return set2.filter { it >= minElement }.toSet()"}
{"problem": "fun findCommonElements(list1: List<Int>, list2: List<Int>): List<Int> {\n    \"\"\"\n    Given two lists, find the common elements between them.\n\n    Parameters:\n    list1 (List): First list to check for common elements\n    list2 (List): Second list to check for common elements\n\n    Returns:\n    commonElements (List): List of common elements between list1 and list2\n    \"\"\"", "solution": "\n    // Initialize an empty list to store the common elements\n    val commonElements = mutableListOf<Int>()\n\n    // Iterate over each element in list1\n    for (element in list1) {\n        // Check if the element is not equal to any elements in list2\n        if (element in list2) {\n            // Add the element to the commonElements list\n            commonElements.add(element)\n        }\n    }\n\n    return commonElements"}
{"problem": "fun findSum(nums: List<Int>): Int {\n    \"\"\"\n    Takes a list of numbers as input and returns the sum of all the numbers greater than 10.\n\n    Args:\n    nums (List): A list of numbers\n\n    Returns:\n    Int: The sum of all the numbers greater than 10\n    \"\"\"", "solution": "\n    var total = 0\n\n    // Iterate over each number in the input list\n    for (num in nums) {\n        // Check if the number is greater than 10\n        if (num > 10) {\n            // Add the number to the total\n            total += num\n        }\n    }\n\n    return total"}
{"problem": "fun findCriminals(criminals: List<Triple<String, Int, String>>, searchTerms: List<String>): List<Triple<String, Int, String>> {\n    \"\"\"\n    This function takes a list of criminals and a list of search terms\n    and returns a list of criminals that match the search terms.\n\n    Args:\n    criminals (List): A list of all the criminals' information\n    searchTerms (List): A list of search terms for finding specific criminals\n\n    Returns:\n    List: A list of criminals that match the search terms\n\n    Example:\n    criminals = listOf(Triple(\"John Doe\", 35, \"Male\"), Triple(\"Jane Smith\", 28, \"Female\"), Triple(\"Michael Johnson\", 42, \"Male\"))\n    searchTerms = listOf(\"Male\")\n\n    findCriminals(criminals, searchTerms) => listOf(Triple(\"John Doe\", 35, \"Male\"), Triple(\"Michael Johnson\", 42, \"Male\"))\n    \"\"\"", "solution": "\n    val matchingCriminals = mutableListOf<Triple<String, Int, String>>()\n    for (criminal in criminals) {\n        if (searchTerms.all { it in criminal.toList() }) {\n            matchingCriminals.add(criminal)\n        }\n    }\n    return matchingCriminals\n}\n\nval criminals = listOf(Triple(\"John Doe\", 35, \"Male\"), Triple(\"Jane Smith\", 28, \"Female\"), Triple(\"Michael Johnson\", 42, \"Male\"))"}
{"problem": "fun intersectionOfSequenceAndAdditionAssignment(sequence: List<Int>, number: Int): List<Int> {\n    \"\"\"Given a sequence and a number, find the intersection of the sequence after adding the number to each element.\n\n    Args:\n        sequence (List): A list of integers.\n        number (Int): An integer to be added to each element of the sequence.\n\n    Returns:\n        List: A list with the intersection of elements after adding the number.\n    \"\"\"", "solution": "\n    var result = sequence[0] + number\n    for (i in 1 until sequence.size) {\n        val currentSet = mutableSetOf<Int>()\n        for (j in result) {\n            currentSet.add(j + sequence[i])\n        }\n        result = currentSet.intersect(result.toSet()).toList()\n    }\n    return result\n}"}
{"problem": "fun findSpecialChars(string: String): List<Char> {\n    /**\n     * Given a string, find and return a list of all special characters that are surrounded by uppercase letters.\n     *\n     * @param string The input string to search for special characters.\n     * @return A list of special characters that satisfy the given condition.\n     *\n     * Example:\n     * findSpecialChars(\"Ab#cD*efG\") // returns ['#', '*']\n     */", "solution": "\n    val specialChars = mutableListOf<Char>()\n\n    for (i in 1 until string.length - 1) {\n        if (string[i].isUpperCase()) {\n            if (!string[i - 1].isLetter() && !string[i + 1].isLetter()) {\n                specialChars.add(string[i])\n            }\n        }\n    }\n\n    return specialChars\n}\n\nfun main() {\n    val missingCode = \"Ab#cD*efG\"\n    val result = findSpecialChars(missingCode)\n    println(result)\n}"}
{"problem": "fun calculateFactorial(n: Int): Int {\n    /**\n     * This function calculates the factorial of a given number using nested ternary operators within a basic while loop.\n     *\n     * @param n The number for which factorial needs to be calculated.\n     * @return The factorial of the input number.\n     */", "solution": "\n    var factorial = 1\n\n    var number = n\n    while (number > 1) {\n        factorial *= if (number > 1) number else 1\n        number--\n    }\n\n    return factorial\n}\n\nfun main() {\n    println(calculateFactorial(5))  // Output: 120\n}"}
{"problem": "fun whileSubtraction(baseNumber: Int, subtractValue: Int): Int {\n    /**\n     * This exercise requires you to write a basic while loop syntax to perform a subtraction operation.\n     * Given a base number, your task is to subtract the subtractValue from the baseNumber using a while loop \n     * and return the final result.\n     *\n     * @param baseNumber an integer representing the base number\n     * @param subtractValue an integer representing the value to subtract from the base number\n     * @return The final result after subtracting the subtractValue from the baseNumber\n     */", "solution": "\n    var result = baseNumber\n\n    while (result >= subtractValue) {\n        result -= subtractValue\n    }\n\n    return result\n}"}
{"problem": "fun calculateTotalSales(revenueList: List<Double>): Double {\n    /**\n     * Given a list of revenues for different products, this function calculates the total sales in floating-point \n     * format.\n     *\n     * @param revenueList A list of revenue values for different products.\n     * @return The total sales calculated from the revenue list.\n     */", "solution": "\n    var totalSales = 0.0\n\n    for (revenue in revenueList) {\n        totalSales += revenue\n    }\n\n    return totalSales\n}"}
{"problem": "fun findAffordableItems(budget: Double, items: Map<String, Double>): List<String> {\n    /**\n     * Given a budget and a dictionary of items with their prices,\n     * find the items that are less expensive than the budget.\n     *\n     * @param budget The maximum amount of money the interior designer can spend.\n     * @param items A dictionary mapping item names to their prices.\n     * @return A list of item names that are less expensive than the budget.\n     */", "solution": "\n    val affordableItems = mutableListOf<String>()\n\n    for ((item, price) in items) {\n        if (price < budget) {\n            affordableItems.add(item)\n        }\n    }\n\n    return affordableItems\n}"}
{"problem": "fun musicianDict(musicianList: List<String>): Map<String, Int> {\n    /**\n     * This exercise is to create a dictionary for a musician, where the keys are the genres of music they play and the values are the number of albums they have released in that genre.\n     *\n     * @param musicianList A list of genres for a musician.\n     * @return A dictionary containing the count of albums released in each genre.\n     */", "solution": "\n    val genreDict = mutableMapOf<String, Int>()\n    var i = 0\n\n    while (i < musicianList.size) {\n        val genre = musicianList[i]\n        genreDict[genre] = genreDict.getOrDefault(genre, 0) + 1\n        i++\n    }\n\n    return genreDict\n}"}
{"problem": "fun nurseSchedule(schedule: List<Pair<String, String>>, nurseName: String) {\n    /**\n     * A nurse's schedule is given as a list of tuples, where each tuple represents a shift with start and end time.\n     * Loop through the schedule and find the shifts where the nurse named \"nurseName\" is not available. Print the number of such shifts.\n     *\n     * @param schedule A list of tuples representing shifts in the format (startTime, endTime)\n     * @param nurseName The name of the nurse\n     */", "solution": "\n    var unavailableShifts = 0\n\n    for (shift in schedule) {\n        val (startTime, endTime) = shift\n\n        if (!nurseNameAvailable(nurseName, shift)) {\n            unavailableShifts++\n        }\n    }\n\n    println(\"Number of shifts where $nurseName is not available: $unavailableShifts\")\n}"}
{"problem": "fun findHighestPeak(elevations: List<Int>): Int? {\n    /**\n     * Given a list of elevations representing a geographic region, \n     * find the highest peak.\n     *\n     * @param elevations A list of integers representing elevations.\n     * @return The highest peak (an integer).\n     */", "solution": "\n    if (elevations.isEmpty()) return null\n\n    var highestPeak = elevations[0]\n    for (elevation in elevations) {\n        if (elevation > highestPeak) {\n            highestPeak = elevation\n        }\n        // Break out of the loop if the current elevation is greater than 5000\n        if (elevation > 5000) break\n    }\n\n    return highestPeak\n}"}
{"problem": "fun calculateVolumes(spheres: List<Double>): List<Double> {\n    /** This function calculates the volumes of spheres given their radii. */", "solution": "\n    val volumes = mutableListOf<Double>()\n    for (radius in spheres) {\n        // Complete the code to calculate the volume of a sphere using the formula (4/3) * pi * radius^3\n        val volume = (4.0 / 3.0) * Math.PI * (radius * radius * radius)\n        volumes.add(volume)\n    }\n    return volumes\n}\n\nval radii = listOf(2.0, 3.0, 4.0, 5.0)\nval sphereVolumes = calculateVolumes(radii)\nprintln(sphereVolumes)\n\n// Output: [33.51029333333333, 113.09722666666666, 268.08234666666664, 523.5983333333332]"}
{"problem": "fun countCommonCharacters(therapistNotes: String, patientNotes: String): Int {\n    /**\n    This function takes in two strings, therapistNotes and patientNotes,\n    and returns the count of common characters between the two strings.\n    */", "solution": "\n    val commonCharacters = mutableSetOf<Char>()\n    for (char1 in therapistNotes) {\n        for (char2 in patientNotes) {\n            // Check if character is common\n            if (char1 == char2) {\n                commonCharacters.add(char1)\n            }\n        }\n    }\n    return commonCharacters.size\n}"}
{"problem": "fun replaceCommonCharacters(therapistNotes: String, patientNotes: String): String {\n    /**\n    This function takes in two strings, therapistNotes and patientNotes,\n    and replaces any common characters between the two strings with '#'.\n    It returns the modified therapistNotes string.\n    */", "solution": "\n    val modifiedNotes = StringBuilder()\n    for (char1 in therapistNotes) {\n        if (char1 in patientNotes) {\n            // If character is common, replace it with '#'\n            modifiedNotes.append('#')\n        } else {\n            modifiedNotes.append(char1)\n        }\n    }\n    return modifiedNotes.toString()\n}"}
{"problem": "fun findCommonElements(data1: Tuple<String>, data2: Tuple<String>): Tuple<String> {\n    /**\n    Write a function that takes in two tuples, `data1` and `data2`, which contains data related to biological studies.\n    The function should return a tuple containing only the elements that exist in both `data1` and `data2`, preserving the order.\n    */", "solution": "\n    val commonElements = mutableListOf<String>()\n    for (elem in data1) {\n        if (elem in data2) {\n            commonElements.add(elem)\n        }\n    }\n    return commonElements.toTypedArray().toList() // Returning as a list, Kotlin doesn't have tuples natively\n}"}
{"problem": "fun updateActorDetails(actorData: List<Map<String, Any>>): List<Map<String, Any>> {\n    /**\n    This function takes a list of dictionaries containing actor/actress details. It updates the salary of each actor\n    based on their experience and returns the updated list.\n    */", "solution": "\n    for (actor in actorData) {\n        // Update the salary based on the actor's experience\n        when (actor[\"experience\"] as Int) {\n            in 0..4 -> actor[\"salary\"] = (actor[\"salary\"] as Double) * 1.1\n            in 5..9 -> actor[\"salary\"] = (actor[\"salary\"] as Double) * 1.2\n            else -> actor[\"salary\"] = (actor[\"salary\"] as Double) * 1.3\n        }\n    }\n    return actorData\n}"}
{"problem": "fun findCommonLetters(artist1: String, artist2: String): String {\n    /**\n    This function takes in two artist names as arguments and returns a string containing all the common letters\n    between the two names, using a while loop and tuple slicing.\n    */", "solution": "\n    if (artist1.isEmpty() || artist2.isEmpty()) {\n        throw IllegalArgumentException(\"Artist name cannot be empty\")\n    }\n\n    val commonLetters = StringBuilder()\n    var i = 0\n\n    while (i < artist1.length) {\n        var j = 0\n        while (j < artist2.length) {\n            if (artist1[i] == artist2[j]) {\n                commonLetters.append(artist1[i])\n                break\n            }\n            j++\n        }\n        i++\n    }\n\n    return commonLetters.toString()\n}"}
{"problem": "fun nurseIsBusy(schedule: List<Int>): Boolean {\n    /**\n    A nurse is busy for half of the day and must take a break for 30 minutes every hour.\n    Given a schedule that represents the nurse's availability during the day,\n    write a function that determines if there is a gap long enough for the nurse to take a break.\n    */", "solution": "\n    val breakLength = 30 // minutes\n    var gapLength = 0\n    for (slot in schedule) {\n        if (slot == 0) {\n            gapLength++\n        } else {\n            if (gapLength >= breakLength) {\n                return true\n            }\n            gapLength = 0 // reset gap length\n        }\n    }\n    return gapLength >= breakLength\n}"}
{"problem": "fun createAnimalTuple(name: String, species: String, size: String, weight: Double, age: Int): Tuple<String> {\n    /**\n    This exercise requires you to create a tuple containing information about an animal. \n    The tuple should include the name, species, size, weight, and age of the animal.\n    */", "solution": "\n    if (name is String && species is String && size is String && weight is Double && age is Int) {\n        val animalTuple = Pair(name, species, size, weight, age) // Using Pair to simulate tuple\n\n        if (weight > 100) {\n            println(\"Warning: This animal is significantly heavier than average.\")\n        }\n\n        if (age < 1) {\n            println(\"This animal is very young\")\n        }\n\n        return animalTuple\n    }\n    throw IllegalArgumentException(\"Invalid input types\")\n}"}
{"problem": "fun intersectSlicingConjugateAbs(x: String): Pair<String, Double> {\n    /**\n    This exercise involves applying slicing to a complex number, then computing its conjugate and absolute value.\n    */", "solution": "\n    // Creating a complex number\n    val complexNum = x.toDouble()\n\n    // Slicing the real and imaginary parts\n    val realPart = complexNum.real\n    val imagPart = complexNum.imag\n\n    // Computing the conjugate of the complex number\n    val conjugate = complex(realPart, -imagPart)\n\n    // Computing the absolute value of the complex number\n    val absoluteValue = abs(complexNum)\n\n    // Return the conjugate and absolute value\n    return Pair(conjugate.toString(), absoluteValue)\n}"}
{"problem": "fun searchPhotos(tags: List<String>, locations: List<String>, photodatabase: Map<String, List<Map<String, Any>>>): List<Map<String, Any>> {\n    \"\"\"\n    Given a list of tags, a list of locations, and a photo database,\n    this function returns a list of photos that have at least one tag\n    from the tags list and are taken at a location specified in the\n    locations list.\n    \n    Args:\n        tags (List<String>): A list of tags.\n        locations (List<String>): A list of locations.\n        photodatabase (Map<String, List<Map<String, Any>>>): A dictionary representing the photo database.\n        \n    Returns:\n        List<Map<String, Any>>: A list of matching photos.\n    \"\"\"", "solution": "    val result = mutableListOf<Map<String, Any>>()\n    for (location in locations) {\n        if (photodatabase.containsKey(location)) {\n            for (photo in photodatabase[location]!!) {\n                if (tags.any { it in photo[\"tags\"] as List<String> }) {\n                    result.add(photo)\n                }\n            }\n        }\n    }\n    return result\n"}
{"problem": "fun getPhotoLocation(photo: Map<String, Any>): String {\n    \"\"\"\n    Given a photo object, this function returns the location of the photo.\n    \n    Args:\n        photo (Map<String, Any>): A dictionary representing a photo object with 'location' key.\n        \n    Returns:\n        String: The location of the photo.\n    \"\"\"", "solution": "    return if (photo.containsKey(\"location\") && photo[\"location\"] is String) {\n        photo[\"location\"] as String\n    } else {\n        \"Unknown\"\n    }\n"}
{"problem": "fun getSpecialPhotos(photos: List<Map<String, Any>>): List<Map<String, Any>> {\n    \"\"\"\n    Given a list of photo objects, this function returns a list of photos taken at special locations.\n    A location is considered special if it starts with the keyword 'Special:'.\n    \n    Args:\n        photos (List<Map<String, Any>>): A list of dictionaries representing photo objects with 'location' key.\n        \n    Returns:\n        List<Map<String, Any>>: A list of dictionaries representing special photos.\n    \"\"\"", "solution": "    val specialPhotos = mutableListOf<Map<String, Any>>()\n    for (photo in photos) {\n        val location = getPhotoLocation(photo)\n        if (location.startsWith(\"Special:\")) {\n            specialPhotos.add(photo)\n        }\n    }\n    return specialPhotos\n"}
{"problem": "fun findNegativeIndex(vetRecords: Map<String, Int>): Int {\n    \"\"\"\n    Given a dictionary of veterinary records, find the negative index of the animal's name.\n\n    Args:\n    vetRecords (Map<String, Int>): A dictionary containing the animal name as the key and the number of visits as the value.\n\n    Returns:\n    Int: The negative index of the animal's name.\n\n    \"\"\"", "solution": "    val animalNames = vetRecords.keys.toList()\n    var maxVisits = 0\n    for (visits in vetRecords.values) {\n        if (visits > maxVisits) {\n            maxVisits = visits\n        }\n    }\n    for (i in animalNames.indices) {\n        if (vetRecords[animalNames[i]] == maxVisits) {\n            return -(animalNames.size - i - 1)\n        }\n    }\n    return -1 // Return -1 if no animal is found\n"}
{"problem": "fun replaceMissingVowels(text: String): String {\n    \"\"\"\n    Given a text as input, the function replaces all the missing vowels with the letter 'x'.\n    \"\"\"", "solution": "    val vowels = listOf('a', 'e', 'i', 'o', 'u')\n    var resultText = text.lowercase()\n    for (char in resultText) {\n        if (char.isLetter() && char !in vowels) {\n            resultText = resultText.replace(char, 'x')\n        }\n    }\n    return resultText\n"}
{"problem": "fun physicianCodeCompletion(patients: MutableMap<String, MutableList<String>>): MutableMap<String, MutableList<String>> {\n    \"\"\"\n    Given a dictionary of patients with their corresponding medical conditions,\n    modify the list of medical conditions for each patient based on certain conditions.\n\n    - If a patient's age is less than 18, add 'CHILD' to their medical conditions.\n    - If a patient's age is greater than or equal to 65, add 'ELDERLY' to their medical conditions.\n    - If a patient's age is between 18 and 65 (inclusive), add 'ADULT' to their medical conditions.\n\n    Args:\n    patients (Map<String, MutableList<String>>): A dictionary mapping patient names (keys) to their ages (values).\n\n    Returns:\n    Map<String, MutableList<String>>: The same dictionary with modified medical conditions for each patient.\n    \"\"\"", "solution": "    for ((patient, age) in patients) {\n        when {\n            age < 18 -> patients[patient]?.add(\"CHILD\")\n            age in 18..65 -> patients[patient]?.add(\"ADULT\")\n            age >= 65 -> patients[patient]?.add(\"ELDERLY\")\n        }\n    }\n    return patients\n"}
{"problem": "fun findAverageIncome(data: List<List<Map<String, List<Int>>>>): List<Double> {\n    \"\"\"Calculate the average income for each city\"\"\"", "solution": "    val averageIncomes = mutableListOf<Double>()\n    for (cityData in data) {\n        var totalIncome = 0\n        var numHouseholds = 0\n        for (household in cityData) {\n            for (income in household[\"incomes\"]!!) {\n                totalIncome += income\n                numHouseholds++\n            }\n        }\n        if (numHouseholds > 0) {\n            averageIncomes.add(totalIncome.toDouble() / numHouseholds)\n        }\n    }\n    return averageIncomes\n"}
{"problem": "fun intersectionOfNotOperatorAndRepetition(data: List<Int>): List<Int> {\n    \"\"\"\n    This function takes a list of integers as input and returns the intersection \n    of numbers that are NOT divisible by 3 and are repeated at least twice.\n\n    Args:\n    data (List<Int>): A list of integers.\n\n    Returns:\n    List<Int>: A list of integers representing the intersection of numbers that are NOT \n          divisible by 3 and are repeated at least twice.\n    \"\"\"", "solution": "    val uniqueNums = mutableSetOf<Int>()\n    val repeatedNums = mutableSetOf<Int>()\n    val result = mutableListOf<Int>()\n\n    for (num in data) {\n        if (num % 3 != 0) {\n            if (uniqueNums.contains(num)) {\n                repeatedNums.add(num)\n            } else {\n                uniqueNums.add(num)\n            }\n        }\n    }\n\n    for (num in repeatedNums) {\n        if (data.count { it == num } > 1) {\n            result.add(num)\n        }\n    }\n\n    return result\n"}
{"problem": "fun validateInput(choice: Int): Boolean {\n    \"\"\"Check if the choice is valid. Return True if valid, False otherwise.\"\"\"", "solution": "    return choice in 1..10\n"}
{"problem": "fun processChoice(choice: Int) { \n    // Implement the main logic for processing the choice given by the player.\n}", "solution": "\n    // Implement the code to process the choice based on game rules.\n    // If the choice is even, print \"Even choice!\" and continue to next iteration.\n    // If the choice is prime, print \"Prime choice!\" and break out of the loop.\n    // If the choice is divisible by 5, print \"Divisible by 5!\" and return true.\n    // Otherwise, return false.\n"}
{"problem": "fun game() { \n    // Simulate a game with choices made by the player.\n}", "solution": "\n    while (true) { \n        val choice = readLine()?.toInt() ?: continue\n        \n        val valid = validateInput(choice)\n        if (!valid) { \n            println(\"Invalid input. Try again.\")\n            continue\n        }\n        \n        val even = choice % 2 == 0\n        val prime = choice > 1"}
{"problem": "fun calculateFuelUsage(fuelCapacity: Double, distanceTraveled: Double): Double { \n    // Calculate the fuel usage of an aircraft based on its fuel capacity and the distance traveled.\n    // The fuel usage is determined by dividing the distance traveled by the fuel capacity.\n}", "solution": "\n    val fuelUsage = distanceTraveled / fuelCapacity\n    return fuelUsage\n"}
{"problem": "fun determineSpeedRatio(speed: Double, referenceSpeed: Double): Double { \n    // Determine the speed ratio between an aircraft's speed and a reference speed.\n    // The speed ratio is calculated by dividing the speed by the reference speed.\n}", "solution": "\n    val speedRatio = speed / referenceSpeed\n    return speedRatio\n"}
{"problem": "fun modifyExpenses(accountantData: List<Pair<Int, Int>>): List<Int> { \n    // Given a list of accountant's expenses, modify the amounts of the expenses by adding a bonus to each amount.\n}", "solution": "\n    val modifiedExpenses = mutableListOf<Int>()\n    \n    // Iterate over each expense tuple and unpack the amount\n    for ((_, amount) in accountantData) { \n        // Modify the amount by adding a bonus and append it to the modifiedExpenses list\n        modifiedExpenses.add(amount + 1_000_000)\n    }\n    \n    return modifiedExpenses\n"}
{"problem": "fun adjustExposure(photoExposure: Double, targetExposure: Double): Double { \n    // This function takes in the current exposure level of a photo and the target exposure level desired by a photographer.\n}", "solution": "\n    // Iteratively adjust the exposure level until it reaches the target exposure\n    while (Math.abs(photoExposure - targetExposure) > 0.01) { \n        if (photoExposure < targetExposure) { \n            photoExposure += 0.1   // Increase exposure level by 0.1\n            if (photoExposure > 1.0) { \n                photoExposure = 1.0   // Limit maximum exposure level to 1.0\n            }\n        } else { \n            photoExposure -= 0.1   // Decrease exposure level by 0.1\n            if (photoExposure < 0.0) { \n                photoExposure = 0.0   // Limit minimum exposure level to 0.0\n            }\n        }\n    }\n    return photoExposure\n"}
{"problem": "fun calculateAverageDepth(rockLayers: List<Int>, numShifts: Int): Double { \n    // This function takes a list of rock layers and the number of times the shift operators should be applied. It calculates the average depth of the rock layers after applying the shift operators.\n}", "solution": "\n    val shiftedLayers = rockLayers.toMutableList()\n    \n    for (shift in 0 until numShifts) { \n        for (i in shiftedLayers.indices) { \n            if (i == 0) { \n                shiftedLayers[i] = shiftedLayers[i] shl 1\n            } else { \n                shiftedLayers[i] = shiftedLayers[i] shr 1\n            }\n        }\n    }\n    val totalDepth = shiftedLayers.sum()\n    val averageDepth = totalDepth.toDouble() / shiftedLayers.size\n    return averageDepth\n"}
{"problem": "fun createTupleFromStringMath(text: String): Pair<Double, Double> { \n    // Given a string containing mathematical expressions separated by commas, create a tuple of the evaluated expressions.\n}", "solution": "\n    // Initialize an empty list to store the evaluated expressions\n    val result = mutableListOf<Double>()\n    \n    // Remove any whitespaces from the text\n    val expressions = text.replace(\" \", \"\").split(\",\")\n    \n    // Iterate over each expression and evaluate it\n    for (expr in expressions) { \n        result.add(eval(expr))\n    }\n    \n    // Return the result list as a tuple\n    return Pair(result[0], result[1])\n"}
{"problem": "fun findCommonElements(lst1: List<Int>, lst2: List<Int>): List<Int> { \n    // Given two lists, return a new list containing the common elements between them.\n}", "solution": "\n    val commonElements = mutableListOf<Int>()\n    \n    // TODO: Use slicing and null as a placeholder to find the common elements between lst1 and lst2\n    for (i in lst1.indices) { \n        if (lst1[i] == lst2[i] || lst2[i] == null) { \n            commonElements.add(lst1[i])\n        }\n    }\n    \n    return commonElements\n"}
{"problem": "fun findMissingItems(items: List<Int>): List<Int> { \n    // This exercise requires the archaeologist to find the missing items in a given list of findings.\n}", "solution": "\n    // Determine the minimum and maximum values in the given list\n    val minItem = items.minOrNull() ?: return emptyList()\n    val maxItem = items.maxOrNull() ?: return emptyList()\n    \n    // Generate a range of numbers from the minimum to the maximum item, inclusive\n    val completeRange = (minItem..maxItem).toList()\n    \n    // Initialize an empty list to store the missing items\n    val missingItems = mutableListOf<Int>()\n    \n    // Iterate through the complete range\n    for (num in completeRange) { \n        // Check if the current number from the complete range is not in the given items list\n        if (num !in items) { \n            // Append the missing number to the missingItems list\n            missingItems.add(num)\n        }\n    }\n    return missingItems\n"}
{"problem": "fun animalTimesTwo(animal1: Int, animal2: Int): Int {\n    \"\"\"\n    This function takes in two animals and returns the result of multiplying their values.\n    However, one of the animals needs to be either a land animal or a water animal.\n    Your task is to complete the code by using the AND and XOR operators to check the following conditions:\n    - If both animals are land animals, return 0.\n    - If both animals are water animals, return 0.\n    - If one animal is a land animal and the other is a water animal, return the product of the animals' values.\n    \n    Args:\n    animal1 (Int): The value of the first animal.\n    animal2 (Int): The value of the second animal.\n    \n    Returns:\n    Int: The result of multiplying the animals' values based on the given conditions.\n    \"\"\"", "solution": "\n    return if (animal1 == 0 && animal2 != 0) || (animal1 != 0 && animal2 == 0) {\n        animal1 * animal2\n    } else {\n        0\n    }\n"}
{"problem": "fun tuplesAndInfiniteLoops(aerospaceElement: String): Tuple {\n    \"\"\"This exercise explores the concepts of tuples and infinite loops in the context\n    of aerospace engineering. Your task is to complete the code by implementing the\n    missing parts and ensuring an infinite loop that manipulates the given aerospace\n    element as a tuple.\n\n    Args:\n    - aerospaceElement (String): The aerospace element to be manipulated.\n\n    Returns:\n    - Tuple: The modified aerospace element.\n    \"\"\"", "solution": "\n    val modifiedElement = mutableListOf<Char>()\n\n    while (true) {\n        println(\"Please select an option:\")\n        println(\"1. Remove duplicate characters in the aerospace element.\")\n        println(\"2. Reverse the order of characters in the aerospace element.\")\n        println(\"3. Count the occurrence of a specific character in the aerospace element.\")\n        println(\"4. Exit the program.\")\n\n        val choice = readLine()\n\n        when (choice) {\n            \"1\" -> {\n                // Remove duplicates\n            }\n            \"2\" -> {\n                // Reverse characters\n            }\n            \"3\" -> {\n                // Count characters\n            }\n            \"4\" -> return modifiedElement.toTuple()\n        }\n    }\n"}
{"problem": "fun uniquePairs(membershipList: List<String>): List<Pair<String, String>> {\n    \"\"\"\n    Given a list of names representing the members in a biomedical engineering team, \n    this function returns a list of all unique pairs of team members.\n\n    Example:\n    >>> uniquePairs(listOf(\"Alice\", \"Bob\", \"Charlie\"))\n    [(\"Alice\", \"Bob\"), (\"Alice\", \"Charlie\"), (\"Bob\", \"Charlie\")]\n\n    Args:\n    - membershipList: A list of strings representing the names of the team members\n    \n    Returns:\n    - A list of pairs representing all unique pairs of team members\n    \"\"\"", "solution": "\n    val pairs = mutableListOf<Pair<String, String>>()\n    val n = membershipList.size\n\n    for (i in 0 until n) {\n        for (j in i + 1 until n) {\n            pairs.add(Pair(membershipList[i], membershipList[j]))\n        }\n    }\n\n    return pairs\n"}
{"problem": "fun unconditionedTernaryOperator(input1: Any?, input2: Any?, input3: Any?): Any? {\n    \"\"\"\n    Given three inputs (input1, input2, input3), the function should return the value of input1 if it is True, otherwise it should return the value of input2 if it is True, otherwise it should return the value of input3.\n    \"\"\"", "solution": "\n    return if (input1 as? Boolean == true) {\n        input1\n    } else if (input2 as? Boolean == true) {\n        input2\n    } else {\n        input3\n    }\n"}
{"problem": "fun intersectionOfLoops(list1: List<Int>, list2: List<Int>): List<Int> {\n    \"\"\"\n    This exercise focuses on list comprehension and executing nested loops.\n    Given two lists, list_1 and list_2, your task is to find the common elements between them using list comprehension.\n    \"\"\"", "solution": "\n    val commonElements = mutableListOf<Int>()\n\n    for (element1 in list1) {\n        for (element2 in list2) {\n            if (element1 == element2) {\n                commonElements.add(element1)\n            }\n        }\n    }\n\n    return commonElements\n"}
{"problem": "fun dancerMoves(dancers: Set<String>): Set<String> {\n    \"\"\"\n    Given a set of dancers, the function takes two nested loops to generate all possible dance moves\n    by pairing each dancer with every other unique dancer in the set. Each dance move is formed by\n    combining the names of the two dancers with a \"+\" sign in between.\n    \n    Args:\n    - dancers: A set of strings representing the names of dancers.\n    \n    Returns:\n    - A set of strings representing all possible dance moves generated from the pairs of dancers.\n    \"\"\"", "solution": "\n    val danceMoves = mutableSetOf<String>()\n    \n    for (dancer1 in dancers) {\n        for (dancer2 in dancers) {\n            if (dancer1 != dancer2) {\n                val danceMove = \"$dancer1+$dancer2\"\n                danceMoves.add(danceMove)\n            }\n        }\n    }\n    \n    return danceMoves\n"}
{"problem": "fun modifyTuples(architects: List<Pair<String, Int>>): List<Pair<String, Double>> {\n    \"\"\"\n    Given a list of tuples containing architects' names and their ages,\n    modify the ages of the architects which are above 30 to their square root.\n\n    Example:\n    Input: [('John', 25), ('Emily', 33), ('Oliver', 42)]\n    Output: [('John', 5), ('Emily', 33), ('Oliver', 6)]\n\n    Args:\n    - architects: List of tuples containing architects' names (String) and ages (Int)\n\n    Returns:\n    - List of tuples with modified ages\n    \"\"\"", "solution": "\n    return architects.map { (name, age) -> Pair(name, if (age > 30) Math.sqrt(age.toDouble()) else age.toDouble()) }\n"}
{"problem": "fun calculateAnimalPopulation(targetPopulation: Int, currentPopulation: Int): Int {\n\n    \"\"\"A zoologist wants to determine how many more animals need to be removed \n    from a specific area to achieve the target population. \n    Complete the function by subtracting the current population from the target population \n    and return the result.\n    \n    Args:\n    targetPopulation (Int): The desired population of animals in the area.\n    currentPopulation (Int): The current population of animals in the area.\n    \n    Returns:\n    Int: The number of additional animals that need to be removed.\n    \"\"\"", "solution": "\n    return targetPopulation - currentPopulation\n"}
{"problem": "fun concatenateAndCheck(actor1: String, actor2: String): Boolean {\n    \"\"\"\n    This exercise requires concatenating two strings and then using the 'is' operator\n    to check if the resulting string is equal to a specific value.\n    \n    Given an actor's first and last name, concatenate them by adding a space in between.\n    Then, using the 'is' operator, check if the resulting string is equal to 'Leonardo DiCaprio'.\n    Return True if they are equal, False otherwise.\n    \n    Args:\n    actor1 (String): The actor's first name.\n    actor2 (String): The actor's last name.\n    \n    Returns:\n    Boolean: True if the concatenated string is equal to 'Leonardo DiCaprio', False otherwise.\n    \n    Example:\n    >>> concatenateAndCheck('Leonardo', 'DiCaprio')\n    True\n    >>> concatenateAndCheck('Brad', 'Pitt')\n    False\n    \"\"\"", "solution": "\n    val fullName = \"$actor1 $actor2\"\n    \n    return fullName == \"Leonardo DiCaprio\"\n"}
{"problem": "fun combineStringsWithLoop(stringsList: List<String>): String {\n    \"\"\"\n    This function takes a list of strings and returns a single string that is\n    the concatenation of all the strings in the list using a loop.\n    \n    Args:\n    stringsList (List<String>): A list of strings to be combined.\n    \n    Returns:\n    String: The combined string.\n    \"\"\"", "solution": "\n    val combinedString = StringBuilder()\n    \n    for (string in stringsList) {\n        combinedString.append(string)\n    }\n    \n    return combinedString.toString()\n"}
{"problem": "fun intersectionOfLists(list1: List<Int>, list2: List<Int>): List<Int> {\n    \"\"\"\n    Takes two lists of integers and returns their intersection using a loop.\n\n    Args:\n        list1: A list of integers.\n        list2: A list of integers.\n\n    Returns:\n        A list containing the common elements between list1 and list2.\n    \"\"\"\n}", "solution": "\n    val intersection = mutableListOf<Int>()\n    for (num1 in list1) {\n        for (num2 in list2) {\n            if (num1 == num2) {\n                intersection.add(num1)\n            }\n        }\n    }\n    return intersection\n"}
{"problem": "fun nestedLoopExercise(sequence: List<Int>): List<Pair<Int, Int>> {\n    \"\"\"\n    This exercise requires you to iterate over a sequence using nested loops.\n    \n    Given a sequence of numbers, you need to find all the pairs of numbers that sum up to a given target value.\n    Your task is to complete the code to find and return a list of pairs where each pair represents numbers\n    that sum up to the target value.\n    \n    Args:\n    - sequence (list): The sequence of numbers to iterate over.\n    \n    Returns:\n    - list: List of pairs representing numbers that sum up to the target value.\n    \"\"\"\n}", "solution": "\n    val target = 10\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in sequence.indices) {\n        for (j in i + 1 until sequence.size) {\n            if (sequence[i] + sequence[j] == target) {\n                pairs.add(Pair(sequence[i], sequence[j]))\n            }\n        }\n    }\n    return pairs\n"}
{"problem": "fun danceRoutine(dancer: MutableList<String>, routine: List<Triple<String, Int, Int>>) {\n    \"\"\"\n    Dancer performs a dance routine by modifying the elements using indexing.\n\n    Args:\n    dancer: A list of dance moves performed by the dancer.\n    routine: A list of elements that need to be modified using indexing.\n\n    Returns:\n    None\n    \"\"\"\n}", "solution": "\n    for (element in routine) {\n        val (move, startIndex, endIndex) = element\n\n        if (startIndex in dancer.indices) {\n            dancer[startIndex] = move.repeat(endIndex - startIndex + 1)\n        }\n    }\n\n    println(\"Final Dance Routine:\")\n    dancer.forEach { println(it) }\n"}
{"problem": "fun removeAndConcatenate(lst1: MutableList<Int>, lst2: List<Int>): List<Int> {\n\n    \"\"\"\n    The function takes two lists as input and performs the following operations:\n    1. Removes all elements from lst1 that are present in lst2.\n    2. Concatenates the remaining elements in lst1 and lst2, ensuring no duplicates.\n    Finally, it returns the concatenated list.\n\n    Args:\n    lst1 (list): First list of elements\n    lst2 (list): Second list of elements\n\n    Returns:\n    list: Concatenated list with elements from both input lists\n\n    \"\"\"\n}", "solution": "\n    lst1.removeAll(lst2)\n    val concatenatedList = (lst1 + lst2).distinct()\n    return concatenatedList\n"}
{"problem": "fun dancerMatrixMultiplication(matrix1: List<List<Int>>, matrix2: List<List<Int>>): List<List<Int>> {\n    \"\"\"\n    This function performs matrix multiplication using nested loops for a dancer routine.\n\n    Args:\n    matrix1 (list): The first matrix to be multiplied\n    matrix2 (list): The second matrix to be multiplied\n\n    Returns:\n    list: The resulting matrix after matrix multiplication\n    \"\"\"\n}", "solution": "\n    if (matrix1[0].size != matrix2.size) {\n        throw IllegalArgumentException(\"The number of columns in matrix1 must match the number of rows in matrix2\")\n    }\n\n    val resultMatrix = List(matrix1.size) { MutableList(matrix2[0].size) { 0 } }\n\n    for (i in matrix1.indices) {\n        for (j in matrix2[0].indices) {\n            for (k in matrix2.indices) {\n                resultMatrix[i][j] += matrix1[i][k] * matrix2[k][j]\n            }\n        }\n    }\n\n    return resultMatrix\n"}
{"problem": "fun calculateDistance(points: List<Pair<Int, Int>>): Double {\n    \"\"\"\n    This function takes a list of points and calculates the total distance between each consecutive pair of points.\n\n    Args:\n    - points: a list of points represented as pairs (x, y)\n\n    Returns:\n    - distance: the total distance between all pairs of points\n    \"\"\"\n}", "solution": "\n    var distance = 0.0\n    for (i in 0 until points.size - 1) {\n        val (x1, y1) = points[i]\n        val (x2, y2) = points[i + 1]\n        val pairDistance = Math.sqrt(((x2 - x1).toDouble().pow(2) + (y2 - y1).toDouble().pow(2)))\n        distance += pairDistance\n    }\n    return distance\n"}
{"problem": "fun findCommonCrops(farmer1Crops: List<String>, farmer2Crops: List<String>): List<String> {\n    \"\"\"\n    This function finds the common crops between two farmers.\n\n    Args:\n    farmer1Crops (list): List of crops grown by farmer 1\n    farmer2Crops (list): List of crops grown by farmer 2\n\n    Returns:\n    commonCrops (list): List of common crops grown by both farmers\n    \"\"\"\n}", "solution": "\n    val commonCrops = mutableListOf<String>()\n\n    for (crop in farmer1Crops) {\n        if (crop in farmer2Crops) {\n            commonCrops.add(crop)\n        }\n    }\n\n    return commonCrops\n"}
{"problem": "fun identifyArchitect(age: Int, experience: Int, skills: List<String>): String {\n    \"\"\"\n    This function determines whether a person qualifies as an architect based on their age, experience, and skills.\n\n    Args:\n    age (int): The age of the person.\n    experience (int): The experience (in years) of the person.\n    skills (list): A list of skills possessed by the person.\n\n    Returns:\n    str: A message indicating whether the person qualifies as an architect or not.\n    \"\"\"\n}", "solution": "\n    if (age < 25) {\n        return \"Sorry, you must be at least 25 years old to be considered as an architect.\"\n    }\n\n    if (experience < 5) {\n        return \"Sorry, you must have at least 5 years of experience to be considered as an architect.\"\n    }\n\n    if (!skills.containsAll(listOf(\"design\", \"planning\", \"construction\"))) {\n        return \"Sorry, you must possess design, planning, and construction skills to be considered as an architect.\"\n    }\n\n    return \"Congratulations! You qualify as an architect.\"\n"}
{"problem": "fun findIntersection(coordinates1: List<Pair<Int, Int>>, coordinates2: List<Pair<Int, Int>>): List<Pair<Int, Int>> {\n    /**\n     * This function finds the intersection of two sets of coordinates.\n     *\n     * Args:\n     *     coordinates1 (List<Pair<Int, Int>>): The first set of coordinates.\n     *     coordinates2 (List<Pair<Int, Int>>): The second set of coordinates.\n     *\n     * Returns:\n     *     List<Pair<Int, Int>>: The intersection of the two sets of coordinates.\n     */\n}", "solution": "\n    val intersection = mutableListOf<Pair<Int, Int>>()\n    for (coord1 in coordinates1) {\n        for (coord2 in coordinates2) {\n            if (coord1 == coord2) {\n                intersection.add(coord1)\n                break\n            }\n        }\n    }\n    return intersection\n"}
{"problem": "fun calculateLandArea(geographicalData: List<Map<String, Any>>): Double {\n\n    /**\n     * This function calculates the total land area of a given region based on the geographical data.\n     *\n     * Args:\n     *     geographicalData (List<Map<String, Any>>): A list of geographical features including the name and area of each feature.\n     *\n     * Returns:\n     *     Double: The total land area of the region.\n     */\n}", "solution": "\n    var landArea = 0.0\n\n    for (feature in geographicalData) {\n        if (feature[\"type\"] == \"land\") {\n            landArea += feature[\"area\"] as Double\n        }\n    }\n\n    return landArea\n"}
{"problem": "fun calculateMaxLoad(designLimit: Double, materialStrength: Double, safetyFactor: Double): Double {\n    /**\n     * Calculates the maximum load that a structure can handle.\n     *\n     * Args:\n     *     designLimit (Double): The maximum allowable load specified in the design code.\n     *     materialStrength (Double): The ultimate strength of the material used in the structure.\n     *     safetyFactor (Double): The safety factor used to account for uncertainties in loads and materials.\n     *\n     * Returns:\n     *     Double: The maximum load that the structure can handle.\n     */\n}", "solution": "\n    var maxLoad = 0.0\n\n    for (i in 0..designLimit.toInt()) {\n        val load = i * materialStrength\n\n        if (load >= (designLimit * safetyFactor)) {\n            break\n        }\n\n        maxLoad = load\n    }\n\n    return maxLoad\n"}
{"problem": "fun findIntersection(athletes: List<List<String>>): List<String> {\n    /**\n     * This function takes a list of athletes' names and returns a list\n     * of the athletes who participate in all the sports given.\n     *\n     * Args:\n     *     athletes (List<List<String>>): A list of athletes' names.\n     *\n     * Returns:\n     *     List<String>: A list of athletes who participate in all sports.\n     */\n}", "solution": "\n    var commonAthletes = athletes[0].toMutableList()\n\n    for (athlete in athletes.subList(1, athletes.size)) {\n        val tempCommonSports = mutableListOf<String>()\n\n        for (sport in athlete) {\n            if (sport in commonAthletes) {\n                tempCommonSports.add(sport)\n            }\n        }\n\n        commonAthletes = tempCommonSports\n    }\n\n    return commonAthletes\n"}
{"problem": "fun copyAndLoop(list1: List<Int>, list2: List<Int>): List<Int> {\n    /**\n     * Given two lists of integers, copy the common elements from both lists into a new list.\n     * Iterate over each element of both lists using a loop and add the common elements to a new list.\n     * Return the new list containing the common elements.\n     */\n}", "solution": "\n    val commonElements = mutableListOf<Int>()\n\n    for (num1 in list1) {\n        for (num2 in list2) {\n            if (num1 == num2 && num1 !in commonElements) {\n                commonElements.add(num1)\n            }\n        }\n    }\n\n    return commonElements\n"}
{"problem": "fun createTupleFromStringAndSubtraction(string: String, subtract: Boolean): List<Int> {\n    /**\n     * This function takes a string as input and subtracts the ASCII value of each character \n     * from its corresponding index in the string. It returns a tuple of the calculated results.\n     *\n     * Args:\n     *     string: A string representing the input text.\n     *     subtract: A boolean indicating whether subtraction should be performed.\n     *\n     * Returns:\n     *     A list containing the calculated results.\n     *\n     * Example:\n     * >>> createTupleFromStringAndSubtraction(\"Code\", true)\n     * [-2, 100, 101, 97]\n     */\n}", "solution": "\n    val result = mutableListOf<Int>()\n    for ((i, char) in string.withIndex()) {\n        result.add(if (subtract) char.code - i else char.code + i)\n    }\n\n    return result\n"}
{"problem": "fun getCommonElements(list1: List<Int>, list2: List<Int>): List<Int> {\n    /**\n     * Given two lists, find the common elements between them.\n     *\n     * Args:\n     *     list1: A list of elements.\n     *     list2: Another list of elements.\n     *\n     * Returns:\n     *     A list containing the common elements found between list1 and list2.\n     *\n     * Example:\n     * >> getCommonElements(listOf(1, 2, 3, 4, 5), listOf(4, 5, 6, 7, 8))\n     * Output: [4, 5]\n     */\n}", "solution": "\n    val commonElements = mutableListOf<Int>()\n\n    for (element in list1) {\n        if (element in list2 && element !in commonElements) {\n            commonElements.add(element)\n        }\n    }\n\n    return commonElements\n"}
{"problem": "fun countVowels(name: String): Int {\n    /**\n     * This exercise requires you to manipulate strings and understand the concept of short-circuiting with if-else.\n     *\n     * Write a function that takes a string as input and returns the count of vowels in that string.\n     *\n     * You must use a loop to iterate through each character of the string and an if-else statement to check if the character is a vowel.\n     * However, you should express the if-else statement in a way that utilizes short-circuiting to improve performance.\n     *\n     * Note: Consider both uppercase and lowercase vowels.\n     *\n     * Example:\n     * countVowels(\"Astronomer\") -> 4\n     *\n     * Explanation:\n     * The string \"Astronomer\" has 4 vowels: 'A', 'o', 'e', 'e'.\n     */\n}", "solution": "\n    val vowels = setOf('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')\n    var count = 0\n\n    for (char in name) {\n        if (char in vowels) count++\n    }\n\n    return count\n"}
{"problem": "fun canDance(dancer: Int, dancers: List<Int>): Boolean {\n\n/** Given a list of dancers, return true if the given dancer is present in the first half and also if the given dancer is taller than all the other dancers in the second half of the list. Otherwise, return false. */\n}", "solution": "\n    val firstHalf = dancers.subList(0, dancers.size / 2)\n    val secondHalf = dancers.subList(dancers.size / 2, dancers.size)\n\n    return dancer in firstHalf && secondHalf.all { dancer > it }\n"}
{"problem": "fun createTypedTuple(selection: String): List<Pair<String, Int>> {\n    /**\n     * Given a selection of historical events, create a list of pairs using the selection string.\n     *\n     * @param selection A string representing historical events, separated by semicolons.\n     * @return A list of pairs, where each pair contains the event name and its year.\n     */", "solution": "\n    val events = selection.split(\";\")  // Split the selection by semicolons\n    val eventTuples = mutableListOf<Pair<String, Int>>()  // Store each event as a pair\n\n    for (event in events) {\n        var eventYear = \"\"  // Variable to store the year of the event\n        var eventName = \"\"  // Variable to store the name of the event\n\n        // Extract the event name and year from the selection\n        for (char in event) {\n            if (char.isDigit()) {\n                eventYear += char\n            } else {\n                eventName += char\n            }\n        }\n\n        // Ignore events without year information\n        if (eventYear.isNotEmpty()) {\n            val eventTuple = eventName.trim() to eventYear.trim().toInt()  // Create the pair containing the event name and year\n            eventTuples.add(eventTuple)  // Add the pair to the list of event pairs\n        }\n    }\n\n    return eventTuples\n"}
{"problem": "fun farmerCowsTuple(numCows: Int): List<Int> {\n    /**\n     * A farmer wants to keep track of the number of cows she owns.\n     *\n     * This function returns a list containing consecutive numbers starting from 1 up to the given 'numCows'.\n     *\n     * @param numCows The number of cows to track.\n     * @return A list of integers representing each cow.\n     */", "solution": "\n    val cows = mutableListOf<Int>()  // Initialize an empty list\n\n    var i = 1  // Start the counter at 1\n    while (i <= numCows) {\n        cows.add(i)  // Add the current number to the list\n        i += 1  // Increment the counter\n    }\n\n    return cows\n"}
{"problem": "fun precedenceOfLogicalOperatorsAndCreatingSet(): Set<Boolean> {\n    /**\n     * Given logical expressions, evaluate each one, prioritize logical operator precedence, and return a set.\n     *\n     * @return A set containing the results of each logical expression.\n     */", "solution": "\n    val result1 = (true && false) || true || false\n    val result2 = !(true && false) || (!(true || false))\n\n    // Creating a set with the results\n    return setOf(result1, result2)\n"}
{"problem": "fun calculateAverageIncome(data: List<Map<String, Any>>): Double {\n    /**\n     * Given a list of maps containing information on income and population,\n     * calculate the average income per person.\n     *\n     * @param data List of maps, where each map contains 'income' and 'population' keys.\n     * @return The average income per person.\n     */", "solution": "\n    var totalIncome = 0.0\n    var totalPopulation = 0\n\n    for (entry in data) {\n        val income = entry[\"income\"] as Int\n        val population = entry[\"population\"] as Int\n\n        totalIncome += income\n        totalPopulation += population\n    }\n\n    val averageIncome = totalIncome / totalPopulation\n\n    return \"%.3f\".format(averageIncome).toDouble()\n"}
{"problem": "fun calculateMean(numbers: List<Int>): Double? {\n    /**\n     * This function takes a list of integers as input and calculates the mean (average) of the numbers.\n     *\n     * @param numbers List of integers.\n     * @return The mean value or null if the list is empty.\n     */", "solution": "\n    if (numbers.isEmpty()) return null\n\n    val sumOfNumbers = numbers.sum()\n\n    return sumOfNumbers.toDouble() / numbers.size\n"}
{"problem": "fun calculateMedian(numbers: List<Int>): Double? {\n    /**\n     * This function takes a list of integers as input and calculates the median of the numbers.\n     * In case of an even number of elements, the average of the two middle values is returned.\n     *\n     * @param numbers List of integers.\n     * @return The median value or null if the list is empty.\n     */", "solution": "\n    if (numbers.isEmpty()) return null\n\n    val sortedNumbers = numbers.sorted()\n    val midIndex = sortedNumbers.size / 2\n\n    return if (sortedNumbers.size % 2 == 1) {\n        sortedNumbers[midIndex].toDouble()\n    } else {\n        (sortedNumbers[midIndex - 1] + sortedNumbers[midIndex]) / 2.0\n    }\n"}
{"problem": "fun calculateStrengthDiff(selection: List<String>, intensity: Float): Map<String, Map<String, Any>> {\n    /**\n     * Simulates a physical therapy session to calculate the difference in strength of selected muscles.\n     *\n     * @param selection List of muscle groups selected for evaluation.\n     * @param intensity Intensity level applied during evaluation.\n     * @return A map containing the complex conjugate and absolute value of the difference in strength for each muscle.\n     */", "solution": "\n    val results = mutableMapOf<String, Map<String, Any>>()\n\n    for (muscle in selection) {\n        val measuredStrength = somePhysicalTherapyMethod(muscle, intensity)\n\n        val conjugate = measuredStrength.conjugate()\n        val absoluteValue = measuredStrength.absoluteValue\n\n        results[muscle] = mapOf(\"Conjugate\" to conjugate, \"Absolute Value\" to absoluteValue)\n    }\n\n    return results\n"}
{"problem": "fun calculateClientBill(hourlyRate: Float, hoursWorked: Float, additionalCharges: Float): Float {\n    /**\n     * Calculates the total bill for a graphic designer based on hourly rate, hours worked, and additional charges.\n     *\n     * @param hourlyRate The hourly rate of the graphic designer.\n     * @param hoursWorked The number of hours worked.\n     * @param additionalCharges Any additional charges applied to the bill.\n     * @return The total bill for the graphic designer.\n     */", "solution": "\n    var totalBill = 0.0f\n\n    if (hourlyRate > 0 && hoursWorked > 0) {\n        totalBill = hourlyRate * hoursWorked\n\n        if (additionalCharges > 0) {\n            totalBill += additionalCharges\n        }\n    }\n\n    return totalBill\n"}
{"problem": "fun calculateHarvest(farm: List<List<Int>>): Int {\n    /**\n     * Calculates the total harvest count for a farmer's crops.\n     *\n     * @param farm List of lists representing the layout of the farm, where each sublist\n     *             represents a row and elements within each sublist represent the number\n     *             of crops in that location.\n     * @return The total number of crops harvested.\n     */", "solution": "\n    var totalHarvest = 0\n\n    for (i in farm.indices) {\n        for (j in farm[i].indices) {\n            if (farm[i][j] > 0) {\n                totalHarvest += farm[i][j]\n            }\n        }\n    }\n\n    return totalHarvest\n"}
{"problem": "fun findPatientWithCondition(patients: List<String>, condition: String): String? {\n    \"\"\"\n    Given a list of patients and a specific condition,\n    this function should return the first patient who has that condition.\n\n    Args:\n    - patients (List<String>): A list of patient names.\n    - condition (String): The condition to be searched for.\n\n    Returns:\n    - String?: The name of the patient with the given condition or null if no patient has it.\n\n    Example:\n    >>> val patients = listOf(\"John Doe\", \"Alice Smith\", \"Jack Johnson\", \"Jane Brown\")\n    >>> findPatientWithCondition(patients, \"flu\")\n    'John Doe'\n    >>> findPatientWithCondition(patients, \"covid\")\n    'Jack Johnson'\n    >>> findPatientWithCondition(patients, \"migraine\")\n    null\n    \"\"\"", "solution": "    for (patient in patients) {\n        if (condition in patient) {\n            return patient\n        }\n    }\n    return null"}
{"problem": "fun findCommonChars(str1: String, str2: String): List<Char> {\n    \"\"\"\n    This exercise is to help the Marketing Manager to find the common characters between two strings using an unconditioned ternary operator and a while loop.\n    The function takes two strings as arguments and returns a list of common characters found in both strings.\n\n    Example:\n    findCommonChars(\"hello\", \"world\") should return ['l', 'o'].\n\n    Your task is to complete the code below by using an unconditioned ternary operator and a while loop to solve the exercise.\n    \"\"\"", "solution": "    val commonChars = mutableListOf<Char>()\n    var i = 0\n    while (i < str1.length) {\n        if (str1[i] in str2) commonChars.add(str1[i])\n        i++\n    }\n    return commonChars"}
{"problem": "fun findCommonElements(rock1: List<String>, rock2: List<String>): List<String> {\n\n    \"\"\"A geologist wants to find the common elements between two rocks.\n    The function takes in two lists, rock1 and rock2, which represent the composition of the rocks.\n    It returns a new list with the common elements found in both rocks.\n    Use the 'not in' operator to check if an element from rock1 exists in rock2.\n    Difficulty: Difficult\"\"\"", "solution": "    val commonElements = mutableListOf<String>()\n\n    for (element in rock1) {\n        if (element in rock2) {\n            commonElements.add(element)\n        }\n    }\n\n    return commonElements"}
{"problem": "fun createTupleWithOrOperator(books: List<String>, movies: List<String>): Pair<String, String> {\n    \"\"\"\n    This function takes two lists of items and returns a tuple containing all the items that are present in at least one of the lists.\n\n    Args:\n    - books: A list of books.\n    - movies: A list of movies.\n\n    Returns:\n    - A tuple containing all the items that are present in at least one of the lists.\n\n    Example:\n    createTupleWithOrOperator(['Harry Potter', 'Lord of the Rings'], ['The Godfather', 'Lord of the Rings'])\n    Output: ('Harry Potter', 'Lord of the Rings', 'The Godfather')\n    \"\"\"", "solution": "    val combinedList = books + movies  // Combine both lists\n    val uniqueItems = combinedList.toSet().toList()  // Remove duplicates\n    val sortedItems = uniqueItems.sorted()  // Sort the items alphabetically\n    return Pair(sortedItems)  // Convert list to Pair"}
{"problem": "fun librarianCheckBookReturned(bookIsBorrowed: Boolean, bookIsOverdue: Boolean): Boolean {\n\n    \"\"\"\n    A librarian wants to check if a book has been returned and if it is overdue.\n    Complete the function 'librarianCheckBookReturned' that takes in two boolean arguments:\n    - bookIsBorrowed: indicating whether the book has been borrowed or not (True/False)\n    - bookIsOverdue: indicating whether the book is overdue or not (True/False)\n\n    The function should return a boolean value:\n    - True if the book has been returned and is overdue\n    - False if the book has not been returned or is not overdue\n\n    For example:\n    - librarianCheckBookReturned(True, True) should return True\n    - librarianCheckBookReturned(True, False) should return False\n    - librarianCheckBookReturned(False, True) should return False\n    - librarianCheckBookReturned(False, False) should return False\n    \"\"\"", "solution": "    return bookIsBorrowed && bookIsOverdue"}
{"problem": "fun compareLists(list1: List<Int>, list2: List<Int>): List<Int> {\n    \"\"\"\n    Given two lists, return a new list containing the elements that appear in both lists.\n\n    Example:\n    compareLists([1, 2, 3, 4], [3, 4, 5, 6]) -> [3, 4]\n\n    Required knowledge: booleans, identity comparison, list iteration.\n    \"\"\"", "solution": "    val commonElements = mutableListOf<Int>()\n\n    for (element in list1) {\n        if (element in list2 && element !in commonElements) {\n            commonElements.add(element)\n        }\n    }\n    return commonElements"}
{"problem": "fun calculateTotalIncome(income: Pair<Double>, expenses: Pair<Double>): Double {\n    \"\"\"\n    Given two tuples containing income and expenses, return the total income after deducting expenses.\n\n    Args:\n        income (Pair<Double>): A pair containing different sources of income.\n        expenses (Pair<Double>): A pair containing different expenses.\n\n    Returns:\n        Double: Total income after deducting expenses.\n    \"\"\"", "solution": "    var totalIncome = income.first + income.second\n\n    for (expense in expenses) {\n        totalIncome -= expense\n    }\n\n    return totalIncome"}
{"problem": "fun calculateNetProfit(income: Pair<Double>, expenses: Pair<Double>): Double {\n    \"\"\"\n    Given two tuples containing income and expenses, return the net profit after deducting expenses.\n\n    Args:\n        income (Pair<Double>): A pair containing different sources of income.\n        expenses (Pair<Double>): A pair containing different expenses.\n\n    Returns:\n        Double: Net profit after deducting expenses.\n    \"\"\"", "solution": "    val netProfit = calculateTotalIncome(income, expenses)\n\n    return if (netProfit < 0) 0.0 else netProfit"}
{"problem": "fun modifyElementCoordinates(coordinates: MutableList<Pair<Int, Int>>): MutableList<Pair<Int, Int>> {\n    /**\n     * This exercise focuses on a game developer's skill to modify the coordinates of game elements using a for loop.\n     * The 'coordinates' parameter is a list containing the coordinates (x, y) of several game elements. Your task is to modify the second element's x-coordinate by adding 10 to its current value.\n     */", "solution": "\n    for (index in coordinates.indices) {\n        if (index == 1) {\n            coordinates[index] = Pair(coordinates[index].first + 10, coordinates[index].second)\n        }\n    }\n    return coordinates\n}"}
{"problem": "fun updateTuple(tuple1: Pair<Int, Int>, tuple2: Pair<Int, Int>): Pair<Int, Int> {\n    /**\n     * This function takes two tuples, tuple1 and tuple2, and updates tuple1 with the elements from tuple2.\n     * The updated tuple1 is returned.\n     */", "solution": "\n    val list1 = mutableListOf(tuple1.first, tuple1.second)\n    val list2 = listOf(tuple2.first, tuple2.second)\n\n    for (element in list2) {\n        if (element !in list1) {\n            list1.add(element)\n        }\n    }\n    return Pair(list1[0], list1[1])\n}"}
{"problem": "fun replaceElements(lst1: List<Any>, lst2: List<Any>, idx1: Int, idx2: Int): List<Any> {\n    /**\n     * Given two lists lst1 and lst2, and two indices idx1 and idx2, this function returns a new list in which the elements\n     * from idx1 to idx2 (inclusive) in lst1 are replaced by the elements in lst2.\n     */", "solution": "\n    return lst1.subList(0, idx1) + lst2 + lst1.subList(idx2 + 1, lst1.size)\n}"}
{"problem": "fun calculateDistance(point1: Pair<Double, Double>, point2: Pair<Double, Double>): Double {\n    /**\n     * Function to calculate the distance between two points\n     */", "solution": "\n    val x1 = point1.first\n    val y1 = point1.second\n    val x2 = point2.first\n    val y2 = point2.second\n\n    // Calculate the distance using Euclidean distance formula\n    return Math.sqrt(Math.pow(x2 - x1, 2.0) + Math.pow(y2 - y1, 2.0))\n}"}
{"problem": "fun findNearestPoint(point: Pair<Double, Double>, points: List<Pair<Double, Double>>): Pair<Double, Double>? {\n    /**\n     * Function to find the nearest point to a given point\n     */", "solution": "\n    var nearestPoint: Pair<Double, Double>? = null\n    var minDistance = Double.MAX_VALUE\n\n    for (p in points) {\n        val distance = calculateDistance(point, p)\n        if (distance < minDistance) {\n            minDistance = distance\n            nearestPoint = p\n        }\n    }\n    return nearestPoint\n}"}
{"problem": "fun findExcludedCases(cases: Set<String>, validCases: Set<String>): Set<String> {\n    /**\n     * This function takes a set of cases and a set of valid cases as input, and returns a set of excluded cases.\n     */", "solution": "\n    val excludedCases = mutableSetOf<String>()\n\n    for (case in cases) {\n        if (case !in validCases) {\n            excludedCases.add(case)\n        }\n    }\n    return excludedCases\n}"}
{"problem": "fun addComplexNumbers(complex1: Pair<Double, Double>, complex2: Pair<Double, Double>): Pair<Double, Double> {\n    /**\n     * Write a function that takes two complex numbers represented as pairs of floats (real, imag) and returns their sum.\n     */", "solution": "\n    val realPart = complex1.first + complex2.first\n    val imagPart = complex1.second + complex2.second\n    return Pair(realPart, imagPart)\n}"}
{"problem": "fun calculateStrengthDiff(selection: List<String>, intensity: Float): Map<String, Map<String, Any>> {\n    /**\n     * Simulates a physical therapy session to calculate the difference in strength of selected muscles.\n     *\n     * @param selection List of muscle groups selected for evaluation.\n     * @param intensity Intensity level applied during evaluation.\n     * @return A map containing the complex conjugate and absolute value of the difference in strength for each muscle.\n     */", "solution": "\n    val results = mutableMapOf<String, Map<String, Any>>()\n\n    for (muscle in selection) {\n        val measuredStrength = somePhysicalTherapyMethod(muscle, intensity)\n\n        val conjugate = measuredStrength.conjugate()\n        val absoluteValue = measuredStrength.absoluteValue\n\n        results[muscle] = mapOf(\"Conjugate\" to conjugate, \"Absolute Value\" to absoluteValue)\n    }\n\n    return results\n"}
